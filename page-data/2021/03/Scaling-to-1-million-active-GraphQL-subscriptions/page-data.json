{"componentChunkName":"component---src-templates-post-template-js","path":"/2021/03/Scaling-to-1-million-active-GraphQL-subscriptions/","result":{"data":{"markdownRemark":{"id":"d6a47448-9f10-5080-95d3-78702ed8666d","html":"<p>Hasura 是基于 Postgres数据库的 GraphQL 引擎，提供可控制权限的开箱即用的 GraphQL API。到 <a href=\"https://hasura.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">hasura.io</a> 和 <a href=\"https://github.com/hasura/graphql-engine\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">github.com/hasura/graphql-engine</a> 了解更多。</p>\n<!-- endExcerpt -->\n<p>Hasura 可为客户端提供实时查询（基于 GraphQL 订阅）。例如，一个外卖应用使用实时查询显示某特定用户的订单实时状态。</p>\n<p>本文档描述 Hasura 的架构，阐述它是如何支撑百万个并发实时查询的。</p>\n<h2 id=\"原文\" style=\"position:relative;\"><a href=\"#%E5%8E%9F%E6%96%87\" aria-label=\"原文 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>原文</h2>\n<p><a href=\"https://github.com/hasura/graphql-engine/blob/master/architecture/live-queries.md\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Scaling to 1 million active GraphQL subscriptions (live queries)</a></p>\n<h2 id=\"目录\" style=\"position:relative;\"><a href=\"#%E7%9B%AE%E5%BD%95\" aria-label=\"目录 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>目录</h2>\n<ul>\n<li><a href=\"#%E5%8E%9F%E6%96%87\">原文</a></li>\n<li><a href=\"#%E7%9B%AE%E5%BD%95\">目录</a></li>\n<li><a href=\"#%E7%BB%93%E8%AE%BA\">结论</a></li>\n<li><a href=\"#graphql-%E4%B8%8E%E8%AE%A2%E9%98%85\">GraphQL 与订阅</a></li>\n<li><a href=\"#%E5%AE%9E%E7%8E%B0-graphql-%E5%AE%9E%E6%97%B6%E6%9F%A5%E8%AF%A2\">实现 GraphQL 实时查询</a>\n<ul>\n<li><a href=\"#%E5%86%8D%E8%8E%B7%E5%8F%96-graphql-%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C\">再获取 GraphQL 查询结果</a></li>\n<li><a href=\"#hasura-%E7%9A%84%E6%96%B9%E6%B3%95\">Hasura 的方法</a>\n<ul>\n<li><a href=\"#%E4%B8%BB%E6%84%8F-1%E7%BC%96%E8%AF%91-%E4%B8%80%E4%B8%AA-graphql-%E6%9F%A5%E8%AF%A2%E4%B8%BA%E5%8D%95%E4%B8%AA-sql-%E6%9F%A5%E8%AF%A2\">主意 #1：编译 一个 GraphQL 查询为单个 SQL 查询</a></li>\n<li><a href=\"#%E4%B8%BB%E6%84%8F-2%E4%BD%BF%E6%8E%88%E6%9D%83%E5%85%B7%E6%9C%89%E5%A3%B0%E6%98%8E%E6%80%A7\">主意 #2：使授权具有声明性</a></li>\n<li><a href=\"#%E4%B8%BB%E6%84%8F-3%E5%9C%A8%E5%8D%95%E4%B8%AA-sql-%E6%9F%A5%E8%AF%A2%E4%B8%AD%E6%89%B9%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E5%AE%9E%E6%97%B6%E6%9F%A5%E8%AF%A2\">主意 #3：在单个 SQL 查询中批处理多个实时查询</a></li>\n<li><a href=\"#%E4%BD%95%E6%97%B6%E6%89%A7%E8%A1%8C%E5%86%8D%E8%8E%B7%E5%8F%96refetch\">何时执行再获取（refetch）？</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E6%B5%8B%E8%AF%95\">测试</a></li>\n<li><a href=\"#%E6%9C%AC%E6%96%B9%E6%B3%95%E7%9A%84%E4%BC%98%E5%8A%BF\">本方法的优势</a></li>\n<li><a href=\"#%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B\">未来展望</a></li>\n</ul>\n<h2 id=\"结论\" style=\"position:relative;\"><a href=\"#%E7%BB%93%E8%AE%BA\" aria-label=\"结论 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>结论</h2>\n<p><strong>设置：</strong> 每个客户端（Web 或 移动应用）用认证令牌登录并订阅一个实时查询结果。数据存放于 Postgres 数据库。每秒钟更新 Postgres 数据库中的一百万行数据，并确保推送一个新查询结果到客户端。Hasura 是 GraphQL API 的提供者（包含授权）。</p>\n<p><strong>测试：</strong> Hasura 可以并发处理多少个客户端的实施订阅？Hasura 是否可以纵向或横向性能伸缩扩展？</p>\n<img alt=\"\" src=\"https://storage.googleapis.com/graphql-engine-cdn.hasura.io/img/subscriptions-images/main-image-fs8.png\" style=\"width:100%;\">\n<img alt=\"single-instance-results\" src=\"https://storage.googleapis.com/graphql-engine-cdn.hasura.io/img/subscriptions-images/images2/single-instance-fs8.png\" style=\"width:100%;\">\n<table>\n<thead>\n<tr>\n<th>单例配置</th>\n<th>活动实时查询数量</th>\n<th>CPU 平均负载</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1xCPU, 2GB RAM</td>\n<td>5000</td>\n<td>60%</td>\n</tr>\n<tr>\n<td>2xCPU, 4GB RAM</td>\n<td>10000</td>\n<td>73%</td>\n</tr>\n<tr>\n<td>4xCPU, 8GB RAM</td>\n<td>20000</td>\n<td>90%</td>\n</tr>\n</tbody>\n</table>\n<img alt=\"results-horizontally-scaled\" src=\"https://storage.googleapis.com/graphql-engine-cdn.hasura.io/img/subscriptions-images/horizontal-scalability.png\" style=\"width:100%;\">\n<p>当一百万个实时查询的时候，Postgres 的负载不超过 28%，连接数峰值在 850 左右。</p>\n<p>关于配置的说明：</p>\n<ul>\n<li>AWS RDS postgres, Fargate, 使用 ELB 的默认配置，无任何微调</li>\n<li>RDS Postgres: 16xCPU, 64GB RAM, Postgres 11</li>\n<li>Hasura 运行在 Fargate (4xCPU, 8GB RAM per instance) ，采用默认配置</li>\n</ul>\n<h2 id=\"graphql-与订阅\" style=\"position:relative;\"><a href=\"#graphql-%E4%B8%8E%E8%AE%A2%E9%98%85\" aria-label=\"graphql 与订阅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>GraphQL 与订阅</h2>\n<p>GraphQL 让应用开发者轻松地从 API 中精确获取他们想要的数据。</p>\n<p>比如，我们要创建一个外卖应用。Postgres 的架构看起来像这样：</p>\n<img alt=\"postgres schema for food delivery app\" src=\"https://storage.googleapis.com/graphql-engine-cdn.hasura.io/img/subscriptions-images/pg-schema.png\" style=\"width:100%;\">\n<p>应用界面会显示当前用户订单的状态，GraphQL 查询会获取订单最新状态和配送员的定位。</p>\n<img alt=\"order-graphql-query\" src=\"https://storage.googleapis.com/graphql-engine-cdn.hasura.io/img/subscriptions-images/images2/basic-query-fs8.png\" style=\"width:100%;\">\n<p>在底层，查询被当作字符串发送给服务器，经解析、授权后，从数据库中获取应用所需的数据。返回的 JSON 数据结构与请求时的相同。</p>\n<p>进入实时查询：实时查询的主意是订阅特定查询的最新结果。一旦底层的数据改变，服务器应该推送最新结果到客户端。</p>\n<p>乍一看，这完美符合 GraphQL 的使用场景，因为 GraphQL 客户端支持处理大量 WebSockets 连接。用 subscription 替换 query 就能转换查询到实时查询。就是这么简单，如果 GraphQL 服务器可实现的话。</p>\n<img alt=\"order-subscription-query\" src=\"https://storage.googleapis.com/graphql-engine-cdn.hasura.io/img/subscriptions-images/images2/subscription-query-fs8.png\" style=\"width:100%;\">\n<h2 id=\"实现-graphql-实时查询\" style=\"position:relative;\"><a href=\"#%E5%AE%9E%E7%8E%B0-graphql-%E5%AE%9E%E6%97%B6%E6%9F%A5%E8%AF%A2\" aria-label=\"实现 graphql 实时查询 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>实现 GraphQL 实时查询</h2>\n<p>实现实时查询是个痛苦的过程。当你的数据库查询包含授权规则，那么当变更事件发生时，会增加查询结果的计算量。这在 web服务上是一个挑战。像 Postgres 这样的数据库，这相当于在底层表更改时，要保持物化视图最新一样困难困难。另一种方法是为特定查询重新获取全部数据（针对特定授权规则的客户端）。这是我们目前采取的方法。</p>\n<p>其次，构建一个 web服务以一种可伸缩的方式来处理 websockets 有时也有点麻烦，但是某些框架和语言确实使并发编程更容易处理。</p>\n<h3 id=\"再获取-graphql-查询结果\" style=\"position:relative;\"><a href=\"#%E5%86%8D%E8%8E%B7%E5%8F%96-graphql-%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C\" aria-label=\"再获取 graphql 查询结果 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>再获取 GraphQL 查询结果</h3>\n<p>为了理解为什么这里使用再获取(refetching) GraphQL 查询不好，我们来看一个典型的 GraphQL 查询过程：</p>\n<img alt=\"graphql-resolvers\" src=\"https://storage.googleapis.com/graphql-engine-cdn.hasura.io/img/subscriptions-images/resolvers-fs8.png\" style=\"width:100%;\">\n<p>在 GraphQL 查询中，授权 + 数据获取逻辑必须为每个节点运行一次。这很可怕，因为即使稍大一点的查询都会轻易拖垮数据库。运用 ORM 不当时，N+1 问题也是个常见问题，这对数据库性能不好，且难以优化 Postgres 查询。Data loader 类型模式可以缓解该问题，但在底层仍然会多次查询 Postgres 数据库（减少为 GraphQL 查询中有多少个节点）。</p>\n<p>实时查询中，该问题更为严重，因为每个客户端的查询都有一个独一无二的再获取。尽管查询是相同的，考虑到授权规则创建不同的会话变量，每个客户端需要单独的再获取。</p>\n<h3 id=\"hasura-的方法\" style=\"position:relative;\"><a href=\"#hasura-%E7%9A%84%E6%96%B9%E6%B3%95\" aria-label=\"hasura 的方法 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Hasura 的方法</h3>\n<p>如何做得更好？如果申明式映射数据模型到 GraphQL 模式，并使用它创建单个 SQL 数据库查询？这样就能避免多次捣鼓数据库，无论返回中是否有大量项目或 GraphQL 查询中有很多节点。</p>\n<h4 id=\"主意-1编译-一个-graphql-查询为单个-sql-查询\" style=\"position:relative;\"><a href=\"#%E4%B8%BB%E6%84%8F-1%E7%BC%96%E8%AF%91-%E4%B8%80%E4%B8%AA-graphql-%E6%9F%A5%E8%AF%A2%E4%B8%BA%E5%8D%95%E4%B8%AA-sql-%E6%9F%A5%E8%AF%A2\" aria-label=\"主意 1编译 一个 graphql 查询为单个 sql 查询 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>主意 #1：编译 一个 GraphQL 查询为单个 SQL 查询</h4>\n<p>Hasura 部分功能是作为转译器，它使用数据模型到 GraphQL 模式的映射信息的元数据，编译 GraphQL 查询为 SQL 查询，来从数据库获取数据。</p>\n<p>GraphQL 查询  GraphQL 抽象语法树（AST）  SQL 抽象语法树  SQL</p>\n<img alt=\"graphql-to-sql\" src=\"https://storage.googleapis.com/graphql-engine-cdn.hasura.io/img/subscriptions-images/graphql-2-sql-fs8.png\" style=\"width:100%;\">\n<p>这消除了 N+1 查询问题，并允许数据库优化数据获取。</p>\n<p>但这不够，因为解析器（resolver）还应用了授权来强制它只获取权限范围内的数据。因此我们需要将授权规则嵌入到生成的 SQL 中。</p>\n<h4 id=\"主意-2使授权具有声明性\" style=\"position:relative;\"><a href=\"#%E4%B8%BB%E6%84%8F-2%E4%BD%BF%E6%8E%88%E6%9D%83%E5%85%B7%E6%9C%89%E5%A3%B0%E6%98%8E%E6%80%A7\" aria-label=\"主意 2使授权具有声明性 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>主意 #2：使授权具有声明性</h4>\n<p>访问数据时的授权本质上是一种约束，它取决于所获取的数据(或行)的值，以及动态提供的应用程序特定用户的会话变量。例如最普通的，一行数据包含表示数据所有权的字段 <code class=\"language-text\">user_id</code>。或有个关联表 <code class=\"language-text\">document_viewers</code> 来表示用户可查看哪些文档。其他场景中，会话变量本身可能包含与行相关的数据所有权信息，例如，账户管理员可以访问任何帐户 [1,2,3]，其中该信息不存在于当前数据库中，而是存在于会话变量（可能由其他数据系统提供）。</p>\n<p>为了对此建模，我们在 API 层实现了类似于 Postgres RLS 的授权层，以提供用于配置访问控制的声明性框架。如果您熟悉 RLS，可以类比 SQL查询中的当前会话变量为来自 cookie、JWTs 或 HTTP头的 HTTP会话变量。</p>\n<p>顺便说一句，因为我们在许多年前就开始了 Hasura 工程，所以我们在 Postgres RLS特性加入 Postgres 之前就在应用层实现了该特性。我们甚至在的 insert 返回子句中也有与已修复的 Postgres RLS 相同的 bug  <a href=\"https://www.postgresql.org/about/news/1614/%E3%80%82\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://www.postgresql.org/about/news/1614/。</a></p>\n<p>因为在 Hasura 应用层面实现了授权（而不是使用 RLS，传递用户详情给 Postgres 连接的当前会话），这带来一个显著优势，我们等下会看到。</p>\n<p>总而言之，既然授权是声明性的，并且可以在表、视图甚至函数（如果函数返回 SETOF）中使用，那么就可以创建具有授权规则的单个 SQL查询。</p>\n<p>GraphQL 查询  GraphQL 抽象语法树  包含授权规则的内部抽象语法树  SQL 抽象语法树  SQL</p>\n<img alt=\"graphql-to-sql-with-authorization\" src=\"https://storage.googleapis.com/graphql-engine-cdn.hasura.io/img/subscriptions-images/graphql-2-sql-auth-fs8.png\" style=\"width:100%;\">\n<h4 id=\"主意-3在单个-sql-查询中批处理多个实时查询\" style=\"position:relative;\"><a href=\"#%E4%B8%BB%E6%84%8F-3%E5%9C%A8%E5%8D%95%E4%B8%AA-sql-%E6%9F%A5%E8%AF%A2%E4%B8%AD%E6%89%B9%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E5%AE%9E%E6%97%B6%E6%9F%A5%E8%AF%A2\" aria-label=\"主意 3在单个 sql 查询中批处理多个实时查询 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>主意 #3：在单个 SQL 查询中批处理多个实时查询</h4>\n<p>仅凭主意 <a href=\"#%E4%B8%BB%E6%84%8F-1%E7%BC%96%E8%AF%91-%E4%B8%80%E4%B8%AA-graphql-%E6%9F%A5%E8%AF%A2%E4%B8%BA%E5%8D%95%E4%B8%AA-sql-%E6%9F%A5%E8%AF%A2\">#1</a>、<a href=\"#%E4%B8%BB%E6%84%8F-2%E4%BD%BF%E6%8E%88%E6%9D%83%E5%85%B7%E6%9C%89%E5%A3%B0%E6%98%8E%E6%80%A7\">#2</a> 的实现，我们仍会导致这样的情况：连接了 100k 个客户端可能会导致相称的 100k 个 Postgres查询来获取最新数据（假如 100k 个更新，每个更新对应一个客户端）。</p>\n<p>然而，考虑到我们在 API层有所有应用程序用户级会话变量可用，我们实际上可以创建单个 SQL查询来一次为许多客户端再次获取数据！</p>\n<p>假设有客户端运行一个订阅，以获取最新的订单状态和配送员位置。我们可以在查询中创建一个关系，其中包含作为不同行的所有查询变量（订单id）和会话变量（用户id）。然后join查询以获取具有此关系的实际数据，以确保在单个响应中获取多个客户端的最新数据。这将允许同时为多个用户获取最新的结果，即使它们提供的参数和会话变量是完全动态的，并且仅在查询时可用。</p>\n<img alt=\"graphql-to-sql-multiplexed\" src=\"https://storage.googleapis.com/graphql-engine-cdn.hasura.io/img/subscriptions-images/multiplexed-fs8.png\" style=\"width:100%;\">\n<h4 id=\"何时执行再获取refetch\" style=\"position:relative;\"><a href=\"#%E4%BD%95%E6%97%B6%E6%89%A7%E8%A1%8C%E5%86%8D%E8%8E%B7%E5%8F%96refetch\" aria-label=\"何时执行再获取refetch permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>何时执行再获取（refetch）？</h4>\n<p>我们尝试了多种方法，获取底层数据库更新事件时来再获取查询。</p>\n<ol>\n<li>监听、通知：需要用触发器检测所有表，在消费端（web服务器）重启或网络中断的情况下，被消费事件可能会被丢弃。</li>\n<li>WAL（译注：Write-ahead logging，预写式日志）：Reliable stream，但是 LR 插槽使得横向性能扩展非常困难，并且在托管数据库供应商上通常不可用。繁重的写入负载会污染 WAL，并且需要在应用层进行节流。</li>\n</ol>\n<p>在这些尝试后，我们当前回退到基于时间间隔的轮询来再获取查询。因此，我们不是在有适当事件时再获取，而是根据一个时间间隔再获取查询。这样做有两个主要原因：</p>\n<ol>\n<li>当实时查询中使用的声明性权限和条件很简单时，在某种程度上可以将数据库事件映射到特定客户端的动态查询上（比如 <code class=\"language-text\">order_id</code> = 1 and <code class=\"language-text\">user_id</code> = cookie.<code class=\"language-text\">session_id</code>），但是对于复杂的查询会变得棘手（比如查询 <code class=\"language-text\">'status' ILIKE 'failed_%'</code>）。声明性权限有时也可以跨表使用。我们在研究这种方法以及基本的增量更新方面投入了大量的精力，并且在生产中有<a href=\"https://www.postgresql.eu/events/pgconfeu2018/sessions/session/2195/slides/144/Implementing%20Incremental%20View%20Maintenance%20on%20PostgreSQL%20.pdf\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">几个小项目</a>采用了类似的方法。</li>\n<li>对于任何应用程序，除非写吞吐量很小，否则无论如何，您最终都会在一个时间间隔内对事件进行节流/防抖（throttling/debouncing）。</li>\n</ol>\n<p>这种方法的缺点是写负载很小时存在延迟。再获取可以立即完成，而不是在几毫秒后。通过适当地调整再获取间隔和批量大小，可以容易地缓解这一问题。到目前为止，我们首先关注的是消除开销最大的瓶颈，即再获取查询。也就是说，我们将在接下来的几个月里继续关注改进，特别是使用事件依赖（在适用的情况下），来潜在地减少实时查询中每隔一段时间再获取的的数量。</p>\n<p>请注意，我们在内部有其他基于事件的方法的驱动程序，如果你有一个用例，目前的方法不能满足你的要求，我们愿意与你合作与提供协助！</p>\n<h2 id=\"测试\" style=\"position:relative;\"><a href=\"#%E6%B5%8B%E8%AF%95\" aria-label=\"测试 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>测试</h2>\n<p>测试基于 Websockets 的实时查询的性能扩展性与可靠性是一项挑战。我们花了几周来构建测试套件和基础自动化工具。设置如下所示：</p>\n<ol>\n<li>一个 nodejs脚本，它运行大量的 GraphQL实时查询客户端，并在内存中记录事件，这些事件随后被存储到数据库中。<a href=\"https://github.com/hasura/subscription-benchmark\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">[github]</a></li>\n<li>一个在数据库上创建写负载的脚本，从而导致所有运行实时查询的客户端之间发生更改（每秒更新一百万行）。</li>\n<li>一旦测试套件完成运行，验证脚本就会在数据库中运行，在该数据库中提取日志/事件以验证没有错误并且所有事件已被接收到。</li>\n<li>仅在以下情况下才认为测试有效：\n<ul>\n<li>收到的有效载荷错误数为 0</li>\n<li>从创建事件到客户端接收的平均延迟小于 1000毫秒</li>\n</ul>\n</li>\n</ol>\n<img alt=\"testing-architecture\" src=\"https://storage.googleapis.com/graphql-engine-cdn.hasura.io/img/subscriptions-images/test-architecture.png\" style=\"width:100%;\">\n<h2 id=\"本方法的优势\" style=\"position:relative;\"><a href=\"#%E6%9C%AC%E6%96%B9%E6%B3%95%E7%9A%84%E4%BC%98%E5%8A%BF\" aria-label=\"本方法的优势 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>本方法的优势</h2>\n<p>Hasura 使实时查询变得触手可及。查询的概念很容易扩展到实时查询，而不需要使用 GraphQL 的开发人员做任何额外工作。这对我们来说是最重要的。</p>\n<ol>\n<li>功能特性丰富的实时查询，全面支持 Postgres operators/aggregations/views/functions 等</li>\n<li>性能可估</li>\n<li>性能可纵向与横向伸缩扩展</li>\n<li>可运行于所有云、数据库供应商平台</li>\n</ol>\n<h2 id=\"未来展望\" style=\"position:relative;\"><a href=\"#%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B\" aria-label=\"未来展望 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>未来展望</h2>\n<p>减少 Postgres 负载，通过：</p>\n<ol>\n<li>映射事件到实时查询</li>\n<li>结果集的增量计算</li>\n</ol>","excerpt":"Hasura 是基于 Postgres数据库的 GraphQL 引擎，提供可控制权限的开箱即用的 GraphQL API。到 hasura.io 和 github.com/hasura/graphql-engine 了解更多。","fields":{"slug":"/2021/03/Scaling-to-1-million-active-GraphQL-subscriptions","categorySlugs":["/category/前端/"],"tagSlugs":["/tag/graph-ql/","/tag/postgres/","/tag/hasura/","/tag/web-sockets/","/tag/realtime/","/tag/翻译/"]},"frontmatter":{"title":"借助 GraphQL 承载 100万并发活动订阅（实时查询）","date":"2021-03-09T10:46:37.121Z","categories":["前端"],"description":null,"tags":["GraphQL","Postgres","Hasura","WebSockets","realtime","翻译"],"slug":"/2021/03/Scaling-to-1-million-active-GraphQL-subscriptions","featured_media":{"childImageSharp":{"gatsbyImageData":{"layout":"fixed","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsTAAALEwEAmpwYAAABSklEQVR42lWSTUsDQQyG5///CqEUiiCCh4IfRcWzB5GqB6GotB5su7szk4/Z9eCbzLZgmGWzM3mTJ5MNu5hZRFXxJFEiEv/8Z6VgM+dsHsK47DPeGjIzCUPaUt6kVlmQqxr7IpYcI7mxGwqRIFACMqBS0fIVm8ftBg6ZgC1wFPMRpyatjlXGMbjhwWmJy4gJ02EYfqsNQ8U3eKt8EKOotSqaXTz0fdfFxe3D+cV8+fKG9fS8XK0+LBkKqESnqBYSWVeJuCOGvi8lpTS/vDmZzK4Wd5Pp6XR2dr24r2KvrvU6RrFRA6Pp1Pn7vt9ud+vNN3ChAQsM0UnGpiBPzh2O46D3T9m3kCIRotGw3zhn4jpL9rCW+bX5aQxeA1lKx2g7iUnI26iLDXEXU9VX2sgc2aToMbD/HodR4PKwydaF+IGNjoqMnD6USm7rD+hTOaNqvPvGAAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/17dfe767550a59c9ea75e82f07f0aa4e/ed3fb/featured_media.png","srcSet":"/static/17dfe767550a59c9ea75e82f07f0aa4e/ed3fb/featured_media.png 800w","sizes":"800px"},"sources":[{"srcSet":"/static/17dfe767550a59c9ea75e82f07f0aa4e/e7773/featured_media.webp 800w","type":"image/webp","sizes":"800px"}]},"width":800,"height":400}}}}},"prevPost":{"fields":{"slug":"/2020/11/frontend-dynamic-plugin-implement"},"frontmatter":{"title":"前端动态插件的实现 with Apollo & React"}},"nextPost":{"fields":{"slug":"/2021/03/askent-realtime-search-implement-and-hasura"},"frontmatter":{"title":"Askent 实时消息搜索的问题及 Hasura 替代"}}},"pageContext":{"slug":"/2021/03/Scaling-to-1-million-active-GraphQL-subscriptions","prevPostSlug":"/2020/11/frontend-dynamic-plugin-implement","nextPostSlug":"/2021/03/askent-realtime-search-implement-and-hasura"}},"staticQueryHashes":["2727970573","3709504828","4110059069"],"slicesMap":{}}