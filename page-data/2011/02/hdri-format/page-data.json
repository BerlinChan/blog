{"componentChunkName":"component---src-templates-post-archived-blog-template-js","path":"/2011/02/hdri-format/","result":{"data":{"archivedBlogPostJson":{"categories":[{"path":"/category/learn/","name":"摄影学习与折腾"}],"tags":[{"name":"CG","path":"/tag/cg/"},{"name":"HDR","path":"/tag/hdr/"},{"name":"摄影","path":"/tag/photography/"}],"featured_media":null,"path":"/2011/02/hdri-format/","date":"2011-02-23T12:48:00.000Z","excerpt":"转载自：http://bbs.hxsd.com/blog.php?b=11561 —— … ","title":"HDRI文件格式简介","content":"<p>转载自：<a href=\"http://bbs.hxsd.com/blog.php?b=11561\">http://bbs.hxsd.com/blog.php?b=11561</a><br />\n&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;<br />\n<strong style=\"line-height: 22px;\">1、HDR简介</strong></p>\n<p>HDR的全称是High-Dynamic Range(高动态范围)。在此，我们先解释一下什么是Dynamic Range（动态范围），动态范围是指图像中所包含的从“最亮”至“最暗”的比值，也就是图像从“最亮”到“最暗”之间灰度划分的等级数；动态范围越大，所能表示的层次越丰富，所包含的色彩空间也越广。那高动态范围(HDR)顾名思义就是从“最亮”到“最暗”可以达到非常高的比值。<!--more--></p>\n<p>在日常生活中我们经常遇到这样的情况：突然从黑暗的房间中走到阳光下，眼睛会无法睁开；清晨阳光会穿透窗帘像光柱般照射入房间；反光度较高的物体在强光下会在周围产生光晕。以上这些生活中随处可见的现象在有HDR以前无法在3D世界中呈现！最大的原因就在于我们使用8～16bit的整数数据，使用8～16bit的整数数据是整个图象处理失真的关键点，所以我们对以往的运算方法做了以下二方面的重大改进：</p>\n<p>1、使用16bit、32bit的数据来提高像素数据的精度。既然继续使用8bit的数据来记录像素的特征不能满足HDR数据所需要的高精度运算的要求，在这种情况下，我们考虑使用16bit、32bit的数据记录来提高像素数据的精度都是可以的。使用了更多的数据来保存像素特征之后，无论是像素的对比度还是像素可以体现的色彩数目都有了巨大的提高。</p>\n<p>2、图象数据采用浮点数据。HDR真正的巨大变革来自于浮点数据的引入。我们可以采用浮点方式来处理和存放亮度数据，抛弃不准确的整数数据；同时计算机在引入浮点数据来存储象素的各个参数并且在运算的全过程都使用浮点数据，这样就可以有效的提高据的精确度。</p>\n<p>那么采用HDR后动态范围最大可以有多大呢？我们看如下的公式，就可以知道我们到底使用了HDR后动态值可以有多大，而动态值的大小直接表现了动态范围的大小：Dynamic Range=log10(Max Intensity / Min Intensity)。公式中intensity是指强度，我们对最大亮度除以最低亮度的结果取对数，得到的结果就是动态范围的相对数值。根据公式计算，当我们在亮度通道使用8bit的的情况下，最高亮度255，最低亮度1。那么计算得出的动态范围就是数值约为2.4，加上单位就是24dB。同理可以计算得出16bit 的亮度通道的动态范围是数值约是4.8，是使用8bit亮度通道的一倍。理论上在HDR模式下，动态范围的数值最高可以到达76.8。在NVIDIA所使用的OpenEXR中表现出来的HDR动态范围的数值最大值约有12.0，远远高出单纯使用16bit亮度通道的所带来的亮度体验，这是采用了优秀算法的结果。OpenEXR所能实现的最大动态范围已经超过了人眼的9，带来了更加真实的视觉体验。</p>\n<p><strong style=\"line-height: 22px;\">2、HDRI文件格式介绍(OpenEXR、Radiance RGBE、Float TIFF)</strong></p>\n<p>HDRI（High-Dynamic Range Image）就是记录采用了HDR技术的图象数据文件。常用的HDRI文件有OpenEXR、Radiance RGBE、FloatTIFF三种格式。</p>\n<p>2.1   OpenEXR文件格式</p>\n<p>OpenEXR是由工业光魔（Industrial Light &amp; Magic）开发的一种HDR标准。OpenEXR文件的扩展名为.exr，常见的OpenEXR文件是FP16（16bit Float Point，也被称为half Float Point）数据图像文件，每个通道的数据类型是FP16，一共四个通道64bpp，每个通道1个bit位用来标志“指数”，5个bit用来存放指数的值，10个bit存放色度坐标（u，v）的尾数，其动态范围从6.14 × 10 ^ -5到6.41 × 10 ^ 4。</p>\n<p>在OpenEXR的算法里面共使用16bit来表示光照数据。虽然看起来和使用16bit亮度通道运算位数相同，但是OpenEXR巧妙的采用了1个bit位用来标志“指数”，5个bit用来存放指数的值，10个bit存放色度坐标的尾数。这样就轻易的解决了浮点数值由于位数少而精度不高的问题。大大的拓宽的在FP16下的动态范围。根据实际的计算结果：在正规化的情况下OpenEXR可以提供和人眼基本相同的动态范围，最暗到最亮是0.00006103515625（6.14 × 10 ^ -5）到65504（6.41 × 10 ^ 4），动态范围是9.03；非正规化条件下，OpenEXR可以提供从最暗到最亮的数值从0.000000059604644775390625（5.96 × 10 ^ -8 ）到65504（6.41 × 10 ^ 4），化为动态范围表示就是12。</p>\n<p>下面是Still写的OpenEXR读写代码，保存的.exr文件采用Zips压缩编码。</p>\n<p>bool COpenExr::Load(const char fileName[], int&amp; width, int&amp; height, float** pixels)<br />\n{<br />\nstd::vector vecpixels;<br />\nif(!Load(fileName, width, height, vecpixels))<br />\nreturn false;<br />\nint num = width * height * 3;<br />\n*pixels = new float[num];<br />\nif(NULL == *pixels)<br />\nreturn false;<br />\nstd::vector::pointer ptr = &amp;vecpixels[0];<br />\nmemcpy(*pixels, ptr, num * 4);<br />\nreturn true;<br />\n}<br />\nbool COpenExr::Load(const char fileName[],   int&amp; width,   int&amp; height,   std::vector &amp;pixels)<br />\n{<br />\nImf::Array pixelsdata;<br />\nbool bLoad = loadImage(fileName, width, height, pixelsdata);<br />\nif(!bLoad) return false;<br />\nfor(int y = 0; y &lt; height; y++)<br />\n{<br />\nint i = y * width;<br />\nfor(int x = 0; x &lt; width; x++)<br />\n{<br />\nint j = i + x;<br />\nconst Imf::Rgba &amp;rp = pixelsdata[j];<br />\npixels.push_back( float(rp.r));<br />\npixels.push_back( float(rp.g));<br />\npixels.push_back( float(rp.b));<br />\n}<br />\n}<br />\nreturn true;<br />\n}<br />\nbool  COpenExr::loadImage (const char fileName[],  int&amp; width, int&amp; height,  Imf::Array&amp; pixels)<br />\n{<br />\nImf::RgbaInputFile in (fileName);<br />\nImath::Box2i dataWindow = in.dataWindow();<br />\nint dw, dh, dx, dy;<br />\nwidth = dw = dataWindow.max.x &#8211; dataWindow.min.x + 1;<br />\nheight = dh = dataWindow.max.y &#8211; dataWindow.min.y + 1;<br />\ndx = dataWindow.min.x;<br />\ndy = dataWindow.min.y;<br />\npixels.resizeErase (dw * dh);<br />\nin.setFrameBuffer (pixels &#8211; dx &#8211; dy * dw, 1, dw);<br />\ntry<br />\n{<br />\nin.readPixels (dataWindow.min.y, dataWindow.max.y);<br />\n}catch (const exception &amp;e)<br />\n{<br />\nstd::cerr &lt;&lt; e.what() &lt;&lt; std::endl;<br />\nreturn false;<br />\n}<br />\nreturn true;<br />\n}<br />\nbool COpenExr::Save(const char fileName[], int width, int height, const float* pixels)<br />\n{<br />\nstd::vector vecpixels(pixels, pixels + width * height * 3);<br />\nreturn Save(fileName, width, height, vecpixels);<br />\n}<br />\nbool COpenExr::Save(const char fileName[], int width, int height, const std::vector pixels)<br />\n{<br />\nImf::Array pixelsdata;<br />\npixelsdata.resizeErase(width * height);<br />\nfor(int y = 0; y &lt; height; y++)<br />\n{<br />\nint i = y * width;<br />\nfor(int x = 0; x &lt; width; x++)<br />\n{<br />\nint j = i + x;<br />\nhalf r = pixels[j * 3 ];<br />\nhalf g = pixels[j * 3 + 1];<br />\nhalf b = pixels[j * 3 + 2];<br />\npixelsdata[j] = Imf::Rgba(r, g, b);<br />\n}<br />\n}<br />\nreturn SaveImage(fileName, width, height, pixelsdata);<br />\n}<br />\nbool COpenExr::SaveImage(const char fileName[], int width, int height, const Imf::Array  &amp;pixels)<br />\n{<br />\nImf::RgbaOutputFile file (fileName, width, height);<br />\nfile.setFrameBuffer(pixels, 1, width);<br />\ntry<br />\n{<br />\nfile.writePixels(height);<br />\n}catch(const exception &amp;e)<br />\n{<br />\nstd::cerr&lt;&lt; e.what() &lt;        return false;<br />\n}<br />\nreturn true;<br />\n}<br />\n官方库链接地址：<a style=\"word-wrap: break-word; color: #009ec1; text-decoration: none; line-height: normal;\" href=\"http://www.openexr.com/\" target=\"_blank\">http://www.openexr.com/</a></p>\n<p>2.2  Radiance RGBE文件格式</p>\n<p>RGBE文件的扩展名为.hdr，RGBE正式名称为Radiance RGBE格式。这个本来是BR、FR等作为radiance材质的一种格式，也叫做radiance map，后来成为流行的一种HDR格式。所谓E，就是指数。Radiance RGBE文件每个通道为8bit BYTE数据类型，4个通道一共是32 bit。RGBE可以使用RLE压缩编码压缩，也可以不压缩。由文件头、RGBE数据组成。</p>\n<p>文件头如下：</p>\n<p>类型                                  输出格式<br style=\"word-wrap: break-word; line-height: normal;\" />char programtype[16];         //#?Radiancen#Generated by stilln<br style=\"word-wrap: break-word; line-height: normal;\" />float gamma;                      //1.0<br style=\"word-wrap: break-word; line-height: normal;\" />float exposure;                   //1.0<br style=\"word-wrap: break-word; line-height: normal;\" /><br />\n字符串常量                          //FORMAT=32-bit_rle_rgbenn<br style=\"word-wrap: break-word; line-height: normal;\" />int nWidth, int nHeight         //-Y nHeight +X nWidthn <br style=\"word-wrap: break-word; line-height: normal;\" /><br />\nRGBE数据与HDR FP32(RGB)相互转换公式如下：<br style=\"word-wrap: break-word; line-height: normal;\" /><br />\n1、rgbe-&gt;FP32(RGB)<br style=\"word-wrap: break-word; line-height: normal;\" />如果e为0， R = G = B = 0.0，否则：<br style=\"word-wrap: break-word; line-height: normal;\" />R = r * 2^(e – 128 &#8211; 8);<br style=\"word-wrap: break-word; line-height: normal;\" />G = g * 2^(e – 128 &#8211; 8);<br style=\"word-wrap: break-word; line-height: normal;\" />B = b * 2^(e – 128 &#8211; 8);<br style=\"word-wrap: break-word; line-height: normal;\" /><br />\n2、FP32(RGB) -&gt; rgbe<br style=\"word-wrap: break-word; line-height: normal;\" />v = max(R, G, B); <br style=\"word-wrap: break-word; line-height: normal;\" /><br />\n如果v &lt; 1e-32, r = g = b = e = 0, 否则：<br style=\"word-wrap: break-word; line-height: normal;\" /><br />\n将v用科学计算法表示成 v = m * 2 ^ n ( 0 &lt; m &lt; 1)：<br style=\"word-wrap: break-word; line-height: normal;\" />r = R * m *  256.0/v; <br style=\"word-wrap: break-word; line-height: normal;\" />g = G * m *  256.0/v;<br style=\"word-wrap: break-word; line-height: normal;\" />b = B * m *  256.0/v;<br style=\"word-wrap: break-word; line-height: normal;\" />e = n + 128; <br style=\"word-wrap: break-word; line-height: normal;\" /><br />\nStill注：</p>\n<p>1、我们一般说HDR采用FP32，指的是HDR图象运算时候的内存数据类型，而Radiance RGBE文件采用8bit BYTE类型存储HDR数据。也就是说打开Radiance RGBE文件，要使用上面的公式1将Radiance RGBE文件的8bit BYTE文件数据转换为FP 32的HDR内存数据进行运算；保存为Radiance RGBE文件时，要使用上面的公式2将HDR的FP32内存数据转换为Radiance RGBE的8bit BYTE文件数据进行保存。同理，OpenEXR文件的读写也存在将其FP 16的文件数据到HDR的 FP32图象数据的转换；而下面将要讲的Float Tiff是不需要进行数据转换，直接将HDR的FP 32图象数据保存到TIFF文件中即可。</p>\n<p>2、Radiance有多种文件格式，其官方库包含内容比较复杂，所以，实际的读写没有使用其官方库，而是使用了网络上一个简单的C语言读写类，Still并对其进行了部分修改（在文件头写入“Generated  by Still”）。 <br style=\"word-wrap: break-word; line-height: normal;\" /><br />\n读写类链接地址：<a style=\"word-wrap: break-word; color: #009ec1; text-decoration: none; line-height: normal;\" href=\"http://www.graphics.cornell.edu/~bjw/rgbe.html\" target=\"_blank\">http://www.graphics.cornell.edu/~bjw/rgbe.html</a><br style=\"word-wrap: break-word; line-height: normal;\" />官方库链接地址：<a style=\"word-wrap: break-word; color: #009ec1; text-decoration: none; line-height: normal;\" href=\"http://radsite.lbl.gov/radiance/\" target=\"_blank\">http://radsite.lbl.gov/radiance/</a><br style=\"word-wrap: break-word; line-height: normal;\" /><br />\n2.3   FloatTiff文件格式<br style=\"word-wrap: break-word; line-height: normal;\" /><br />\nTiff文件的扩展名为.tif(.tiff)，FloatTiff每个通道为FP32(32bit Float Point)类型，一共3个通道96bpp。用Tiff文件存储HDR数据，直接将HDR的FP32保存到TIFF文件中，有官方库可以利用。下面是Still写的代码样例，HDR数据我采用的是LZW压缩编码：    <br style=\"word-wrap: break-word; line-height: normal;\" /><br />\nbool  CFloatTiff::Load(const char fileName[], int&amp; width, int&amp; height, float** pixels)<br style=\"word-wrap: break-word; line-height: normal;\" />{<br style=\"word-wrap: break-word; line-height: normal;\" />TIFF* fp = NULL;<br style=\"word-wrap: break-word; line-height: normal;\" />if((fp = TIFFOpen(fileName, &#8220;r&#8221;)) == NULL)<br style=\"word-wrap: break-word; line-height: normal;\" />return false;<br style=\"word-wrap: break-word; line-height: normal;\" />//获取信息<br style=\"word-wrap: break-word; line-height: normal;\" />uint16 bps,  spp, datatype, photometric, compression, planarconfig, fillorder;<br style=\"word-wrap: break-word; line-height: normal;\" />//每个通道占据的数据位数<br style=\"word-wrap: break-word; line-height: normal;\" />if( (TIFFGetField(fp, TIFFTAG_BITSPERSAMPLE, &amp;bps) == 0) || (bps != 32))<br style=\"word-wrap: break-word; line-height: normal;\" />return false;<br style=\"word-wrap: break-word; line-height: normal;\" />//每个象素的通道数目<br style=\"word-wrap: break-word; line-height: normal;\" />if((TIFFGetField(fp, TIFFTAG_SAMPLESPERPIXEL, &amp;spp) == 0) || (spp != 3))<br style=\"word-wrap: break-word; line-height: normal;\" />return false;<br style=\"word-wrap: break-word; line-height: normal;\" />//每个通道的数据类型<br style=\"word-wrap: break-word; line-height: normal;\" />if((TIFFGetField(fp, TIFFTAG_SAMPLEFORMAT, &amp;datatype) == 0) || (datatype != AMPLEFORMAT_IEEEFP))<br style=\"word-wrap: break-word; line-height: normal;\" />return false;<br />\n//图像的数据采用的颜色模型<br style=\"word-wrap: break-word; line-height: normal;\" />if((TIFFGetField(fp, TIFFTAG_PHOTOMETRIC, &amp;photometric) == 0) || (photometric != PHOTOMETRIC_RGB))<br style=\"word-wrap: break-word; line-height: normal;\" />return false;<br />\n<br style=\"word-wrap: break-word; line-height: normal;\" />TIFFGetField(fp, TIFFTAG_IMAGEWIDTH, &amp;width);<br style=\"word-wrap: break-word; line-height: normal;\" />TIFFGetField(fp, TIFFTAG_IMAGELENGTH, &amp;height);<br style=\"word-wrap: break-word; line-height: normal;\" />int num = width * height * 3;<br style=\"word-wrap: break-word; line-height: normal;\" />*pixels = new float[num];<br style=\"word-wrap: break-word; line-height: normal;\" />if(NULL == *pixels)<br style=\"word-wrap: break-word; line-height: normal;\" />return false;<br style=\"word-wrap: break-word; line-height: normal;\" /><br />\nif( TIFFReadEncodedStrip(fp, 0, *pixels, width * height * 3 * 4) == -1)<br style=\"word-wrap: break-word; line-height: normal;\" />return false;<br style=\"word-wrap: break-word; line-height: normal;\" /><br />\nTIFFClose(fp);<br style=\"word-wrap: break-word; line-height: normal;\" />return true;<br style=\"word-wrap: break-word; line-height: normal;\" />}<br style=\"word-wrap: break-word; line-height: normal;\" />bool  CFloatTiff::Save(const char fileName[], int width, int height, const float* pixels)<br style=\"word-wrap: break-word; line-height: normal;\" />{<br style=\"word-wrap: break-word; line-height: normal;\" />if(NULL == pixels)<br style=\"word-wrap: break-word; line-height: normal;\" />return false;<br style=\"word-wrap: break-word; line-height: normal;\" /><br />\nTIFF *fp = NULL;<br style=\"word-wrap: break-word; line-height: normal;\" />if((fp = TIFFOpen(fileName, &#8220;w&#8221;)) == NULL)<br style=\"word-wrap: break-word; line-height: normal;\" />return false;<br style=\"word-wrap: break-word; line-height: normal;\" /><br />\nTIFFSetField(fp, TIFFTAG_IMAGEWIDTH, width);<br style=\"word-wrap: break-word; line-height: normal;\" />TIFFSetField(fp, TIFFTAG_IMAGELENGTH, height);<br style=\"word-wrap: break-word; line-height: normal;\" />TIFFSetField(fp, TIFFTAG_COMPRESSION, COMPRESSION_LZW);//COMPRESSION_DEFLATE;<br style=\"word-wrap: break-word; line-height: normal;\" />TIFFSetField(fp, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);<br style=\"word-wrap: break-word; line-height: normal;\" />TIFFSetField(fp, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);<br style=\"word-wrap: break-word; line-height: normal;\" />TIFFSetField(fp, TIFFTAG_BITSPERSAMPLE, 32);<br style=\"word-wrap: break-word; line-height: normal;\" />TIFFSetField(fp, TIFFTAG_SAMPLESPERPIXEL, 3);<br style=\"word-wrap: break-word; line-height: normal;\" />TIFFSetField(fp, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);<br style=\"word-wrap: break-word; line-height: normal;\" /><br />\nif(TIFFWriteEncodedStrip(fp, 0, const_cast(pixels), width * height * 3 * 4) == -1)<br style=\"word-wrap: break-word; line-height: normal;\" />return false; <br style=\"word-wrap: break-word; line-height: normal;\" /><br />\nTIFFClose(fp);<br style=\"word-wrap: break-word; line-height: normal;\" />return true;<br style=\"word-wrap: break-word; line-height: normal;\" />}   <br style=\"word-wrap: break-word; line-height: normal;\" /><br style=\"word-wrap: break-word; line-height: normal;\" />官方库链接地址：<a style=\"word-wrap: break-word; color: #009ec1; text-decoration: none; line-height: normal;\" href=\"http://www.remotesensing.org/libtiff/\" target=\"_blank\">http://www.remotesensing.org/libtiff/</a></p>\n<p>&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;<br />\n转载自：<a href=\"http://bbs.hxsd.com/blog.php?b=11561\">http://bbs.hxsd.com/blog.php?b=11561</a></p>\n"}},"pageContext":{"slug":"/2011/02/hdri-format/"}},"staticQueryHashes":["2727970573","3709504828","4110059069"],"slicesMap":{}}